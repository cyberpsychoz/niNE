# Техническая документация niNE

Этот документ предоставляет глубокий технический обзор фреймворка niNE, описывая его архитектуру, основные компоненты, сетевой протокол и API для разработчиков.

## 1. Обзор архитектуры

niNE использует **клиент-серверную архитектуру**, где сервер является авторитетным источником состояния мира, а клиенты — это визуальные представления этого мира.

- **Сервер**: Написан на `asyncio`, что обеспечивает высокопроизводительную асинхронную обработку сетевых соединений и игровых событий. Он управляет состоянием игроков, логикой плагинов и синхронизацией данных.
- **Клиент**: Построен на 3D-движке **Panda3D**. Он отвечает за рендеринг, обработку пользовательского ввода и взаимодействие с сервером. В клиент интегрирован цикл `asyncio` для сетевого обмена в неблокирующем режиме.
- **Связь**: Обмен данными происходит по защищенному **TCP-соединению с использованием TLS**. Сообщения сериализуются в формат **JSON**.

Ключевым принципом является **слабая связанность** компонентов, которая достигается через централизованную **систему событий (Event System)**.

---

## 2. Основные компоненты ядра (`nine/core`)

### `Application` (`app.py`)
Абстрактный базовый класс для сервера и клиента. Определяет основной жизненный цикл: `run()`, `tick()`, `stop()` и содержит экземпляр `EventManager`.

### `EventManager` (`events.py`)
Реализует паттерн "Издатель-подписчик" (Pub/Sub). Это центральный хаб для всех событий в приложении, позволяющий компонентам взаимодействовать, не зная друг о друге.
- `subscribe(event_type, listener)`: Подписывает функцию `listener` на событие `event_type`.
- `unsubscribe(event_type, listener)`: Отписывает слушателя.
- `post(event_type, data)`: Публикует событие, вызывая всех его подписчиков.

### `NetworkManager` (`network.py`)
Управляет всем сетевым взаимодействием.
- **На сервере**: Запускает `asyncio.start_server`, принимает входящие подключения, создает для каждого клиента отдельную задачу, которая читает данные из сокета. При получении полного сообщения публикует событие `network_message_received`.
- **На клиенте**: Использует `asyncio.open_connection` для подключения к серверу.
- **События**: Генерирует ключевые сетевые события: `network_client_connected`, `network_client_disconnected`, `network_message_received`.

### `DatabaseManager` (`database.py`)
Обеспечивает персистентность данных игроков в базе **SQLite**.
- **Схема**: Таблица `players` с колонками `uuid` (PRIMARY KEY), `name` (UNIQUE), `password_hash`, `salt`, `pos_x`, `pos_y`, `pos_z` и `attributes` (JSON-поле для кастомных данных).
- **API**: Предоставляет методы для CRUD-операций с игроками и их атрибутами. `set_player_attribute` и `get_player_all_attributes` позволяют плагинам легко сохранять и загружать любые данные, связанные с игроком.
- **Безопасность**: Хэширует пароли с использованием `hashlib.pbkdf2_hmac` и "соли".

### `PluginManager` (`plugins.py`)
Отвечает за динамическую загрузку и выгрузку плагинов из директорий `nine/plugins` и `plugins`.
- **Загрузка**: Рекурсивно ищет файлы `.py` и пакеты (папки с `__init__.py`). В найденных модулях ищет классы, унаследованные от `BasePlugin`, создает их экземпляры и вызывает метод `on_load()`.
- **`BasePlugin`**: Базовый класс, от которого должны наследоваться все плагины. В методах `on_load()` и `on_unload()` плагин должен сам подписываться на нужные события и отписываться от них.

---

## 3. Сетевой протокол

Протокол основан на обмене JSON-сообщениями по TCP. Каждое сообщение имеет префикс в виде **4-байтового заголовка**, содержащего длину основного сообщения в формате big-endian unsigned int (`!I`).

`[ 4-byte-length | JSON-payload ]`

### Сообщения: Клиент -> Сервер

#### `auth`
Аутентификация или регистрация игрока. Отправляется сразу после подключения.
- **Направление**: C -> S
- **Поля**:
  - `type: "auth"`
  - `name: str` - Имя игрока.
  - `password: str` - Пароль.
  - `uuid: str` - Уникальный идентификатор клиента. Если игрок с таким `name` существует, сервер обновит его UUID на этот. Если нет, будет создан новый игрок с этим `uuid`.

#### `move`
Обновление позиции игрока. Отправляется при движении.
- **Направление**: C -> S
- **Поля**:
  - `type: "move"`
  - `pos: [float, float, float]` - Новые координаты `[x, y, z]`.

#### `chat_message`
Отправка сообщения в игровой чат.
- **Направление**: C -> S
- **Поля**:
  - `type: "chat_message"`
  - `message: str` - Текст сообщения.

### Сообщения: Сервер -> Клиент

#### `auth_failed`
Отправляется, если аутентификация не удалась.
- **Направление**: S -> C
- **Поля**:
  - `type: "auth_failed"`
  - `reason: str` - Причина отказа (например, "Неверный пароль").

#### `welcome`
Отправляется после успешной аутентификации. Содержит всю информацию, необходимую для начала игры.
- **Направление**: S -> C
- **Поля**:
  - `type: "welcome"`
  - `id: int` - Уникальный ID сессии на сервере.
  - `pos: [float, float, float]` - Начальная позиция игрока.
  - `players: dict` - Словарь с уже подключенными игроками `{id: {name, pos, uuid}}`.

#### `player_joined`
Оповещает клиентов о подключении нового игрока.
- **Направление**: S -> C (broadcast)
- **Поля**:
  - `type: "player_joined"`
  - `id: int` - ID сессии нового игрока.
  - `player_info: {name, pos, uuid}` - Информация о новом игроке.

#### `player_left`
Оповещает клиентов об отключении игрока.
- **Направление**: S -> C (broadcast)
- **Поля**:
  - `type: "player_left"`
  - `id: int` - ID сессии отключившегося игрока.

#### `world_state`
Периодически рассылаемое состояние мира (позиции всех игроков).
- **Направление**: S -> C (broadcast)
- **Поля**:
  - `type: "world_state"`
  - `players: dict` - Словарь с актуальным состоянием всех игроков `{id: {name, pos, uuid}}`.

#### `chat_broadcast`
Рассылка сообщения из чата всем игрокам.
- **Направление**: S -> C (broadcast)
- **Поля**:
  - `type: "chat_broadcast"`
  - `from_name: str` - Имя отправителя.
  - `message: str` - Текст сообщения.

---

## 4. Жизненный цикл сервера

1.  **Инициализация**: Создается `ServerApp`, который инициализирует `NetworkManager`, `DatabaseManager`, `PluginManager` и `EventManager`.
2.  **Запуск**: `asyncio.run(main())` запускает асинхронный цикл.
3.  **Старт сервера**: `NetworkManager.start_server()` открывает TCP-сокет для прослушивания.
4.  **Загрузка плагинов**: `PluginManager.load_plugins()` ищет и инициализирует все плагины.
5.  **Основной цикл**:
    - `broadcast_world_state()`: Асинхронная задача, которая с частотой `TICK_RATE` рассылает всем клиентам `world_state`.
    - `auto_save_world()`: Асинхронная задача, которая каждые 5 минут сохраняет данные всех онлайн-игроков в БД.
    - `main_loop()`: Публикует событие `app_tick` с частотой `TICK_RATE`.
6.  **Обработка сообщений**: При получении сообщения от клиента `NetworkManager` публикует `network_message_received`. `ServerApp` подписан на это событие и обрабатывает базовые сообщения (`auth`, `move`). Если тип сообщения не распознан, он генерирует динамическое событие `server_on_<msg_type>`, на которое могут подписаться плагины (см. `ChatPlugin`).
7.  **Остановка**: По `KeyboardInterrupt` вызывается `stop()`, который сохраняет данные игроков, выгружает плагины (`on_unload`) и закрывает соединение с БД.

---

## 5. Жизненный цикл клиента

1.  **Инициализация**: `GameClient` (наследник `ShowBase` из Panda3D) инициализирует UI, консоль и асинхронный цикл `asyncio`.
2.  **Интеграция `asyncio` и Panda3D**: В `taskMgr` Panda3D добавляется задача `poll_asyncio`, которая в каждом кадре выполняет одну итерацию цикла `asyncio` (`loop.stop(); loop.run_forever()`). Это позволяет обоим циклам (игровому и сетевому) работать "одновременно".
3.  **Подключение**: При попытке логина создается задача `connect_and_read()`, которая устанавливает TLS-соединение.
4.  **Аутентификация**: Сразу после подключения вызывается `on_successful_connection()`, которая отправляет `auth`-сообщение.
5.  **Основной цикл**:
    - `read_messages()`: Постоянно ожидает данные из сокета. При получении полного сообщения вызывает `handle_network_data()` в основном потоке Panda3D через `asyncio_loop.call_soon_threadsafe()`.
    - `update_movement()`: Задача Panda3D, которая проверяет нажатые клавиши и отправляет на сервер `move`-сообщения.
    - `handle_network_data()`: Обрабатывает входящие сообщения от сервера (`welcome`, `world_state` и др.), обновляя состояние игрового мира и модели.

---

## 6. Система плагинов

### Создание плагина
1.  Создайте файл (например, `my_plugin.py`) в директории `nine/plugins`.
2.  Создайте класс, унаследованный от `BasePlugin`.
3.  Определите атрибут `name`.
4.  В методе `on_load()` подпишитесь на нужные события.
5.  В методе `on_unload()` отпишитесь от этих же событий.

### Взаимодействие с ядром
Из плагина доступны:
- `self.app`: Экземпляр `ServerApp`, через который можно получить доступ к другим компонентам, например, к базе данных (`self.app.db`) или списку игроков (`self.app.players`).
- `self.event_manager`: Экземпляр `EventManager` для подписки и публикации событий.

### Пример: `ChatPlugin`
- **`on_load()`**: Подписывается на событие `server_on_chat_message`. Это событие генерируется сервером, когда он получает сообщение с неизвестным ему типом `chat_message`.
- **`handle_chat_message(event_data)`**: Получает данные, отправленные клиентом. Извлекает из них текст сообщения.
- **Публикация**: Формирует новое событие `server_broadcast` с данными для рассылки (`{type: "chat_broadcast", ...}`) и публикует его. `ServerApp` подписан на `server_broadcast` и выполняет фактическую рассылку всем клиентам.

---

## 7. Ключевые события (`EventManager`)

#### Системные
- `app_start`: Публикуется при запуске `Application.run()`.
- `app_tick`: Публикуется в каждом такте основного цикла.
- `app_stop`: Публикуется при вызове `Application.stop()`.

#### Сетевые (генерируются `NetworkManager`)
- `network_server_started`: Сервер успешно запущен.
- `network_client_connected`: Новый клиент подключился. `data` - `ClientConnectedEvent`.
- `network_client_disconnected`: Клиент отключился. `data` - `ClientDisconnectedEvent`.
- `network_message_received`: От клиента получено новое сообщение. `data` - `MessageReceivedEvent`.

#### Серверные (для плагинов)
- `server_broadcast`: Событие-команда для `ServerApp` с просьбой разослать сообщение всем. `data` - `{"data": dict, "exclude_ids": list}`.
- `server_on_<type>`: Динамическое событие, которое `ServerApp` генерирует для любого неопознанного типа сообщения `<type>`. Именно на него подписываются плагины для расширения функционала.