# План Разработки niNE

Этот документ описывает недавние архитектурные изменения и представляет дорожную карту по превращению проекта в полноценный "Конструктор ролевых игр".

---

## 1. Недавняя переработка архитектуры (Завершено)

Проект недавно претерпел значительный рефакторинг для улучшения стабильности, поддерживаемости и архитектурной чистоты.

-   **Унификация клиентов:**
    -   Избыточные `dev_client.py` и `client.py` были объединены. Основной `client.py` теперь поддерживает флаг `--dev` для разработки, который включает предсказание движения на стороне клиента и аутентификацию для разработчиков.
    -   Выделенный, автоматически подключающийся `dev_client.py` был воссоздан для быстрого тестирования, используя ту же базовую логику `GameClient`, но без главного меню.

-   **Разделение конфигураций:**
    -   Клиенты больше не читают `server_config.json`. Это обеспечивает строгое разделение ответственности, при котором клиенты не знают о специфичных настройках сервера.
    -   Детали подключения (хост, порт) теперь передаются через аргументы командной строки или через UI, с разумными значениями по умолчанию.

-   **Централизация сетевого кода:**
    -   Вся низкоуровневая сетевая логика (отправка и получение JSON-сообщений с префиксом длины через SSL) была централизована в модуле `nine.core.network`.
    -   Все клиенты (`client.py`, `dev_client.py`, `dev_cli_client.py`) теперь используют этот общий модуль, что устраняет дублирование кода.

-   **Улучшенная аутентификация на сервере:**
    -   Сервер теперь имеет выделенный поток аутентификации `dev_auth`. Когда в `server_config.json` установлен флаг `allow_dev_client: true`, разработчики могут подключать несколько клиентов без блокировки из-за уникальности имен.

---

## 2. Дорожная карта: Конструктор ролевых игр

Чтобы превратить проект в настоящий "Конструктор ролевых игр", нам необходимо создать системы, которые обеспечат глубокую кастомизацию персонажей, миров и историй. Ниже представлена предлагаемая дорожная карта.

### Фаза 1: Фундаментальные системы

#### A. Расширенное сохранение персонажей
-   **Цель:** Перейти от сохранения только имени и позиции игрока к хранению детализированных данных о персонаже.
-   **Реализация:**
    1.  **Схема БД:** Расширить базу данных SQLite (`nine.db`) новыми таблицами: `characters`, `character_stats`, `character_appearance` и т.д.
    2.  **Класс Player:** Изменить класс `Player` в `nine/core/world.py` для хранения сложных данных (например, характеристики, уровень, здоровье, атрибуты внешности).
    3.  **Загрузка/сохранение данных:** Улучшить `DatabaseManager` для загрузки этих данных при `auth`/`dev_auth` и сохранения их периодически или при отключении.
    4.  **Выбор персонажа:** Перед сообщением `welcome` должен появиться шаг выбора персонажа, если у аккаунта их несколько. Это потребует нового экрана в UI.

#### B. Управление миром и зонами
-   **Цель:** Сервер должен уметь управлять несколькими зонами (например, город, подземелье) и сохранять состояние объектов в них.
-   **Реализация:**
    1.  **Схема БД:** Добавить таблицы для `zones`, `world_objects` (с позицией, вращением, масштабом, типом) и `object_properties`.
    2.  **Класс World:** Рефакторинг `GameWorld` для управления словарем объектов `Zone`. Каждая `Zone` будет содержать свой собственный набор объектов и игроков.
    3.  **Стриминг зон:** Реализовать логику для загрузки/выгрузки зон по мере перемещения игроков между ними. Сервер будет отправлять обновления `world_state` только для текущей зоны игрока.

### Фаза 2: Инструменты для создания контента

#### A. Внутриигровой редактор мира ("Режим Мастера Игры")
-   **Цель:** Позволить пользователям со специальными правами создавать и изменять мир в реальном времени.
-   **Реализация:**
    1.  **Система прав:** Добавить поле `role` в таблицу `accounts` или `characters` в БД (например, `player`, `moderator`, `admin`).
    2.  **Режим клиента GM:** Создать новый режим клиента (например, `client.py --gm`), который активирует специфичный для редактора UI и управление.
    3.  **Новые сетевые сообщения:**
        -   `gm_spawn_object(object_id, pos, rot)`
        -   `gm_delete_object(world_object_id)`
        -   `gm_set_object_property(world_object_id, key, value)`
    4.  **Логика сервера:** Сервер будет проверять, что у клиента есть права 'admin', прежде чем обрабатывать эти сообщения и обновлять БД.
    5.  **UI:** Клиент GM будет иметь простой UI для выбора объектов для спавна и изменения их свойств.

#### B. Система квестов и диалогов на основе данных
-   **Цель:** Создать систему для написания квестов и диалогов с NPC, которая не требует написания нового кода на Python для каждого из них.
-   **Реализация:**
    1.  **Файлы квестов/диалогов:** Определить формат (JSON или YAML) для файлов квестов и диалогов. Эти файлы будут находиться в новом каталоге `content`.
        -   Файл квеста может определять цели (например, `FETCH_ITEM`, `KILL_MONSTER`, `GO_TO_AREA`), награды и ссылки на диалоги.
        -   Файл диалога будет определять дерево текста NPC, ответы игрока и связанные с ними события (например, `start_quest`, `give_item`).
    2.  **Движки на стороне сервера:**
        -   **Движок квестов:** Новый класс на сервере, который загружает все файлы квестов, отслеживает прогресс игрока в БД (таблица `player_quests`) и проверяет выполнение целей.
        -   **Движок диалогов:** Класс, который обрабатывает файлы диалогов и отправляет клиенту сообщения `show_dialogue_ui`.
    3.  **NPC:** Создать базовый класс `NPC`. В БД NPC может иметь `dialogue_id`, который связывает его с определенным файлом диалога.

### Фаза 3: Доработка и расширение

#### A. Расширенный UI кастомизации персонажа
-   **Цель:** Полноценный внутриигровой UI для создания внешности персонажа.
-   **Реализация:**
    1.  **Модульные персонажи:** Модель игрока (`player.egg`) должна быть разделена на модульные части (голова, торс, ноги) или поддерживать морфинг.
    2.  **Экран UI:** Новый экран UI со слайдерами и палитрами для изменения внешности.
    3.  **Поток данных:** UI будет генерировать структуру данных о внешности (например, `{"hair_style": 3, "hair_color": [0.8, 0.2, 0.1]}`), которая будет сохраняться в БД. Когда игрок входит в мир, эти данные отправляются всем клиентам, которые затем применяют их к модели персонажа.

#### B. Навыки и способности
-   **Цель:** Реализовать базовую систему навыков.
-   **Реализация:**
    1.  **Навыки на основе данных:** Определить навыки в JSON-файлах (например, `{"id": "fireball", "damage": 10, "mana_cost": 5}`).
    2.  **Логика сервера:** Сервер проверяет, может ли игрок использовать навык, и рассчитывает его эффект на цель.
    3.  **Обратная связь на клиенте:** Клиенту потребуется воспроизводить анимации и визуальные эффекты при использовании навыка. Это идеальный вариант использования для `EventManager` (`skill_used_event`, `damage_taken_event`).
